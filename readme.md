# ‫Python PEP-8

<h1 align=right>‫Python PEP8</h1>

<p align=right>
‫از جمله مزایایی که برای زبان برنامه‌نویسی پایتون گفته می‌شه این هست که کد‌های این زبان خوانایی بسیار بالایی دارند، امّا حتی این ویژگی هم می‌تونه قربانی سلیقه‌ی شخصی برنامه‌نویس شده و خوانایی رو حداقل برای اشخاص ثالث خواه هم‌تیمی و خواه دیگران بسیار سخت‌تر از کد‌های زبان‌هایی دیگه بکنه. برای رفع این مشکل استانداردی تهیه شده تا حداقل افراد با رعایت قوانین اون بهتر کد‌های هم رو درک کنند، طبیعتاً این کار خیلی مفیده، البته اگه به بهتر شدن کد و مسائلی از جمله open source و … اهمیت بدین.
</p>

<p align=right>
‫این استاندارد اصطلاحاً‌PEP نامیده می‌شه که سرواژه‌ی کلمات عبارت Python Enhancement Proposal هست و قوانینش در صفحه‌ی اون در سایت python.org به آدرس:
<a href="https://www.python.org/dev/peps/pep-0008">
https://www.python.org/dev/peps/pep-0008
</a>
 موجود هست امّا از اونجایی که درک این قوانین برای مبتدی‌هایی مثل من که حتی درکشون از زبان انگلیسی هم در حد بخور و نمیر هست یه خورده سخته و از اونجای دیگه‌ای که من فعلاً مجبورم اونها رو بخونم و یاد بگیرم تا بیشتر از این کد‌های خودم رو به لجن نکشم تصمیم گرفتم تا جایی که درک می‌کنم و از امتحان و خطا نتیجه می‌گیرم رو بنویسم تا حداقل یه خروجی مفید اضافه هم ازش بگیرم، پس این متن لزوماً مستند و موثق نیست و طبیعاً اشتباهاتی داره حتی بعضی از موارد حذف شدن یا هنوز نوشته نشدن که به امید خدا به مرور زمان و با کمک توصیه‌کننده‌گان عزیز حل می‌شن.
</p>

<p align=right>
‫اوّلین چیزی باید در ارتباط با این قوانین باید در نظر داشته باشیم این هست که شما مجاز به زیر پا گذاشتن این قوانین هستن و چیزی که شما رو مجبور به رعایت اون‌ها می‌کنه تصمیم خودتون هست. یعنی شما می‌تونید اصلاً هیچ وقعی بهشون  ننهید و مسیر خودتون رو برید یا دست و پا شکسته تا جایی که می‌تونید رعایتشون کنید و یا حتی جونتون رو پای رعایت اون‌ها بزارید امّا مطمئن باشید کسی از شما به عنوان شهید یاد نمی‌کنه!! تعجب نکنید، چون بعضی جاها مجبورید که این استاندارد رو بشکنید اگر مجبور هم نباشید بدونید که اگر این کار (شکستن استاندارد – عدم رعایتش) رو می‌کردین بهتر بود. اگر براتون سؤال شده که این مواقع کی‌ها هستن چند موردش رو می‌شه اینطوری توضیح داد:
</p>

<p align=right>
‫* زمانی هست که پیروی از قوانین نه تنها باعث افزایش خوانایی برنامه نمی‌شه بلکه بدتر اون رو کاهش می‌ده، حتی برای افرادی که از این قوانین پیروی می‌کنن.
</p>

<p align=right>
‫* یه موقع لازم هست کدی که می‌نویسید با نسخه‌های قدیمی پایتون هماهنگ باشه و اون ورژن از پایتون این خصوصیتی که شما می‌خواین ازش استفاده کنید رو پشتیبانی نمی‌کنه!
</p>

## ‫تورفتگی

<p align=right>
‫همین‌طور که می‌دونید پایتون بر خلاف زبان‌هایی مثل C و ‭C++‬برای بلوک‌گذاری از کروشه‌ها و آکولاد‌ها استفاده نمی‌کنه و به جای اون از تورفتگی‌ها استفاده می‌کنه. برای تورفتگی‌ها می‌شه هم از کاراکتر فاصله و هم کاراکتر tab استفاده کرد و حتماً این رو هم می‌دونید که اندازه‌ی tab توی ویرایشگر‌های مختلف متفاوته برای این شدیداً توصیه می‌شه که برای تورفتگی به جای tab از ۴تا فاصله (space) استفاده کنید.
</p>

## خطوط بلند

<p align=right>
‫حداکثر طول هر خط (حداکثر تعداد کاراکتر‌های موجود در هر خط) برابر ۷۹ است، بنا به دلایلی از جمله گویا عرض استاندارد کاغذ A4 هشتاد کاراکتر هست و گویا از قدیم‌الیام هم خروجی ترمینال هم ‫۸۰ کاراکتر بوده <a href="https://twitter.com/VahidMaani/status/540191064230232064">منابع</a>. ولی قطعاً دستوراتی هستن که طولشون ۸۰ کاراکتر که سهله از ۲۰۰ کاراکتر هم بیشترن، برای نوشتن این‌ها مجبوریم دستور رو به چند خط بشکنیم، قاعده‌ی کلی این هست که خطوط از قسمت داخلی پرانتز‌ها/کروشه‌ها/آکولاد‌ها شکسته بشن امّا مواقعی پیش‌ میاد که این کار امکان‌پذیر نیست پس به انتهای جدیدخط یک کاراکتر \ (backslash) اضافه کرده و خط رو می‌شکنیم. البته به همین راحتی نیست و موارد زیر هستن که دهن برنامه‌نویس رو سرویس می‌کنن:
</p>

* هنگام فراخوانی یک تابع دو حالت امکان‌پذیر هست

  * همه‌ی آرگومان‌ها توی یه خط جدید هستن،‌ در این حالت خطوط جدید فقط یه تورفتگی می‌گیرن
  

    ```python
    foo = long_function_name(
        var_one, var_two,
        var_three, var_four
        )
    ```

  * چند آرگومان در انتهای همان خط هستن، در این حالت خطوط بعدی باید دقیقاً تا ابتدای اوّلین آرگومان تورفتگی بگیرن، حتی اگر مجبور باشیم یک تورفتگی با تعداد کمتر از ۴فاصله اضافه کنیم، برای نمایش بهتر تعداد تورفتگی‌ها، هر تورفتگی رو با ۳تا نقطه و یک خط‌تیره نشون دادم:


    ```python
    foo = long_function_name(var_one, var_two,
    ..._..._..._..._..._..._.var_three, var_four
    ..._..._..._..._..._..._.)
    ```

* در موقع تعریف تابع هم همان قوانین فراخوانی توابع مورد استفاده قرار می‌گیرند با این تفاوت که در حالت اوّلشون تعداد تورفتگی یکی بیشتر می‌شه تا خطوط شکسته شده قاطی دستورات داخلی تابع نشن

    ```python
    def long_function_name(var_one, var_two, var_three,
    ..._..._..._..._..._...var_four
    ..._..._..._..._..._...):
    ..._print(var_one)


    def long_function_name(
    ..._..._var_one, var_two,
    ..._..._var_three, var_four
    ..._..._):
    ..._print(var_one)
    ```

* اگر میخواین خط رو از نزدیکی عملگر باینری بشکنین حتماً این کار رو بعد از عملگر انجام بدین نه قبل از اون

    ```python
    if (this_is_one_thing and
        that_is_another_thing):
        do_something()
    ```

* اگر مجبور هستین که خط رو قبل از عملگر باینری بشکنین حواستون باشه که از یه تورفتگی اضافه استفاده کنید:


    ```python
    if (this_is_one_thing
            and that_is_another_thing):
        do_something()
    ```


* هنگام شکستن خطوط با کاراکتر `\` 

 مثلِ حالت قبل تعداد تورفتگی‌های خطوط جدید یکی بیشتر از تعداد تورفتگی‌های دستور بعدی خواهد بود.
 ‫پرانتز/براکت/آکولاد بسته می‌تونه در سه تا موقعیت قرار بگیره، اوّلی همون انتهای خط هست،‌ دومی در خط جدید و در امتداد تورفتگی‌های خطوط قبلی و در نهایت سومی در خط جدید و درست در کاراکتر اوّل هست. راه حل اوّل چندان جالب نیست و نه تنها هیچ کمکی به خوانایی کد نمی‌کنه بلکه مجبورمون می‌کنه که بریم 

    ```python
    if True:
        my_list = [
            1, 2, 3,
            4, 5, 6
        ]

    if True:
        my_list = [
            1, 2, 3,
            4, 5, 6
            ]
    result = some_function_that_takes_arguments(
        'a', 'b', 'c',
        'd', 'e', 'f'
    )
    ```

<p align=right>
‫در مورد طول خطوط دستورات صحبت کردیم ولی باید این نکته رو هم در نظر داشته باشیم که طول خطوط با ساختار‌های محدود (توضیحات و docstringها) ۷۲ کاراکتر هست. 
</p>

## تب‌ها و فاصله‌ها

<p align=right>
‫گفتیم که برای تورفتگی‌ها فاصله به تب ارجحیت داره ولی اگر کدی رو ویرایش می‌کنید که قبلاً از تب استفاده شده بهتره شما هم همون رویه رو ادامه بدین تا بیشتر از اون کد مشکل‌دار نباشه البته گذشته از اون پایتون ۳ اجازه استفاده ترکیبی از فاصله و تب رو نمی‌ده و در کد‌های پایتون ۲ هم به جای ترکیب تب و فاصله هم فقط از فاصله استفاده کنید. اگر مفسر پایتون ۲ رو با آپشن ‪-t‬ فراخوانی کنید مفسر در مواجه با دستوراتی که از ترکیب تب و فاصله استفاده کرده هشداری بر می‌گرداند و اگر از آپشن ‪-tt‬ استفاده کنید این هشدار تبدیل که خطا خواهد شد.
</p>

## ‫خطوط خالی

‫توابع‌ سطح بالا و تعاریف کلاس‌ها رو با دو خط خالی از هم جدا می‌کنیم و سیستم جداسازی در داخل کلاس یک خط خالی است. البته تعداد بیشتری هم می‌شه برای دلایل مختلف از جمله جداسازی گروهی توابع استفاده کرد برای مثال داخل یک تابع می‌توان بخش‌های منطقی اون رو با خط خالی از بقیه قسمت‌ها جدا کرد.

## ‫کدبندی فایل منبع `Source File Encoding`

<p align=right>
‫کدها در پایتون همیشه باید UTF-8 باشن البته در پایتون ۲ این باید به ASCII تبدیل می‌شه. فایل‌هایی که در پایتون ۲ از ASCII و در پایتون ۳ از UTF-8 استفاده می‌کنن دیگه نباید توضیحی در مورد encoding داشته باشن. در کتابخانه‌های استاندارد encoding‌های غیر پیشفرض فقط برای تست یا زمانی که لازم باشه در توضیحات، docstring ‌ها مثلاً اسم برنامه‌نویس با کاراکتر‌های غیر ASCII نوشته بشه مورد استفاده قرار می‌گیرن.
</p>


## Imports

<p align=right>
‫دستورات `import` باید در خطوط جداگانه‌ای نوشته شوند، برای مثال به جای نوشتن:
</p>

```python
import sys, os
```

‫باید بنویسیم:

```python
import sys
import os
```

‫البته دستور زیر هم درسته:

```python
From subprocess import Popen, PIPE
```

<p align=right>
‫این رو هم یادمون باشه که
<code>import‌</code>
 ها همیشه در بالاترین سطح فایل نوشته می‌شن درست بعد از توضیحات و 
<code>docstring</code>
 های مربوط به این کار.
<code>import</code>
ها با استفاده از قوانین زیر به صورت گروهی دسته‌بندی می‌شن بطوری که بین هر گروه یک خط خالی قرار می‌گیره:

* کتابخانه‌های استاندارد

* کتابخانه‌های وابسته به اشخاص ثالث

* کتابخانه‌ها و برنامه‌های محلی

<p align=right>
‫زمانی که می‌خواهیم یک 
<code>class</code>
 را از ماژول شامل آن 
 <code>import</code>
  کنیم به شکل زیر عمل می‌کنیم:
</p>

```python
from myclass import MyClass
from foo.bar.yourclass import YourClass
```

<p align=right>
‫اگر این اسامی با اسامی محلی تعارض داشتن به شکل زیر عمل می‌کنیم:
</p>

```python
import myclass
import foo.bar.yourclass
```

<p align=right>
‫و در داخل کد به شکل‌های
 <code>myclass.MyClass</code>
 و
 <code>foo.bar.yourclass.YourClass</code>
  استفاده می‌شوند.
‫
از به کار گیری دستور 
 <code>import </code>
  با استفاده از وایلدکارد ( ‪ 
 <code> from <module> import * </code>
  ‬) پرهیز کنید، 
</p>

<h2 align=right>
کاراکتر نقل‌قول
 <code> " , ' </code>
</h2>

<p align=right>
‫در پایتون عبارت‌های نقل‌قول تک کوتیشنِ و جفت کوتیشنِ با هم مشابه‌اند. و این PEP هیچ توصیه‌ای در مورد آن‌ها ندارد، بهتر است برای خود قانونی ایجاد کرده و از آن پیروی کنید. برای پرهیز از بک‌اسلش برای چاپ کوتیشن در داخل متن، اگر عبارت را با تک کوتیشن شروع کرده‌اید از جفت کوتیشن استفاده کنید و برعکس.
</p>

<h2 align=right>‫فاصله در عبارات و دستورات:</h2>

<p align=right>
‫از فاصله‌های نامربوط که در شرایط زیر صدق می‌کنند بپرهیزید:</p>

<p align=right>
‫I. بدون هیچ واسطه در داخل پرانتز‌ها، آکولادها و کروشه‌ها:</p>

```python
Yes:
    spam(ham[1], {eggs: 2})
No:
    spam( ham[ 1 ], { eggs: 2 } )
```

<p align=right>
‫II. بدون هیچ واسطه قبل از کاما، سمی‌کولن(semicolon) و کولن(colon):</p>

```python
Yes:
    if x == 4: print(x, y); x, y = y, x
No:
    if x == 4 : print(x , y) ; x , y = y , x
```

<p align=right>
‫III. برخی اوقات کولن شبیه به یک عملگر دودویی رفتار می‌کنه پس باید ما هم باهاش مثل یه عملگر رفتار کنیم حداقل یه عملگر با اولویت پایین و اطراف اون فاصله بزاریم البته به غیر از زمان‌هایی که عملوند اون حذف شده باشه بطوریکه فاصله از سمت عملوند هم حذف می‌شه:</p>

```python
Yes:
    ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
    ham[lower:upper], ham[lower:upper:], ham[lower::step]
    ham[lower+offset : upper+offset]
    ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
    ham[lower + offset : upper + offset]
No:
    ham[lower + offset:upper + offset]
    ham[1: 9], ham[1 :9], ham[1:9 :3]
    ham[lower : : upper]
    ham[ : ]
```

<p align=right>
‫IV. بدون واسطه قبل از پرانتز باز برای مشخص کردن آرگومان‌های تابع هنگام فراخوانی:</p>

```python
Yes:
    spam(1)
No:
    spam (1)
```

<p align=right>
‫V. بدون واسطه قبل از پرانتز باز برای شروع indexing:</p>

```python
Yes:
    dct['key'] = lst[index]
No:
    dct ['key'] = lst [index]
```

<p align=right>
‫VI. بیش از یک فاصله اطراف تساوی انتساب (یا هر تساوی دیگر) به بهانه‌ی تراز دادن با بقیه:</p>

```python
Yes:
    x = 1
    y = 2
    long_variable = 3
No:
    x             = 1
    y             = 2
    long_variable = 3
```

<h3 align=right>‫ باقی توصیه‌ها:</h3>

<p align=right>
‫I. این عملگر‌های باینری را همیشه با یک فاصله در اطراف آن‌ها محاصره کنید: انتساب ( = )، انتساب‌های تکمیلی (‪+=, -=‬ و …)، مقایسه‌ای‪( == , &lt; , > , != , &lt;> , &lt;= , >= , in , not in , is , is not )‬، بولی (and , or , not).</p>

<p align=right>
‫II. اگر عملگر‌هایی با اولویت‌های متفاوت مورد استفاده قرار گیرند، فقط اطراف عملگر با اولویت کمتر فاصله قرار می‌دهیم البته این بیشتر به تشخیص و سلیقه‌ی شخصی شما بستگی دارد،‌ امّا، هیچ وقت بیشتر از یک فاصله استفاده نکنید و همیشه در هر دو طرف عملگر به یک میزان فاصله قرار دهید.</p>

```python
Yes:
    i = i + 1
    submitted += 1
    x = x*2 – 1
    hypot2 = x*x + y*y
    c = (a+b) * (a-b)
No:
    i=i+1
    submitted +=1
    x = x * 2 – 1
    hypot2 = x * x + y * y
    c = (a + b) * (a - b)
```

<p align=right>
‫III. هنگام استفاده از = برای مقداری دهی اولیه به پارامتر یا مشخص کردن مقدار یک آرگومان اطراف آن از فاصله استفاده نمی‌کنیم.</p>

```python
Yes:
    def complex(real, image=0.0):
        return magic(r=real, i=image)
No:
    def complex(real, image = 0.0):
        return magic(r = real, i = image)
```

<p align=right>
‫IV. استفاده  از جملات مرکّب (چندین جمله در یک خط) اصلاً توصیه نمی‌شه: </p>

```python
Yes:
    if foo == 'blah':
        do_blah_thing()
    do_one()
    do_two()
    do_three()
Rather No:
    if foo == 'blah': do_blah_thing()
    do_one(); do_two(); do_three()
```

<p align=right>
‫V. زمانی که می‌توان ساختار‌های if/for/while را در یک قالب کوچک تک خطی نوشت هرگز آن‌ها را در چندین قالب ننویسید:</p>

```python
Rather No:
    if foo == 'blah': do_blah_thing()
    for x in lst: total += x
    while t &lt; 10: t = delay()
Definitely No:
    if foo == 'blah': do_blah_thing()
    else: do_non_blah_thing()

    try: somthing()
    finally: cleanup()

    do_one(); do_two(); do_three(long, argument,
                                 list, like, this)

    if foo == 'blah': one(); two(); three()
```

<h1 align=right>‫توضیحات:</h1>

<p align=right>
‫وجود توضیحات بی‌ربط به کد، بدتر از این هست که کدی توضیحات نداشته باشه پس سعی کنید موقع تغییر کد اصلاح توضیحات رو هم در اولویت بالا قرار بدین!
</p>

<p align=right>
‫توضیحات باید یک جمله‌ی کامل باشند و حتی اگر توضیح فقط یک عبارت باشه باید اوّلین کلمه‌ش با حروف بزرگ شروع بشه مگر اینکه این کلمه یه شناسه باشه که با حروف کوچیک نوشته می‌شه(شکل شناسه‌ها رو هیچ وقت تغییر ندین)!
</p>

<p align=right>
‫اگر توضیح کوتاه باشه می‌شه نقطه رو از آخر اون حذف کرد. بلوک توضیحات می‌تونه شامل چند پاراگراف که از جملات کاملی تشکیل شدن باشه بطوریکه هر جمله به نقطه ختم می‌شه. بعد از هر جمله‌ای که به نقطه‌ ختم می‌شود دو فاصله لازم است. 
</p>

<p align=right>
‫کدنویس‌های پایتون از کشور‌های غیر انگلیسی زبان: توضیحاتتون رو به انگلیسی بنویسید، مگر اینکه ۱۲۰٪ مطمئن باشید کسی که زبان شما رو متوجه نمی‌شه کدهای شما رو نخواهد خوند.
</p>

<h1 align=right>‫بلوک توضیحات:</h1>

<p align=right>
‫بلوک توضیحات برای همه یا قسمتی از کدی هست که توضیحات در ادامه‌ی اونها اومدن و هم‌سطح همون کد‌ها تورفتگی دارن. هر خط از بلوک توضیحات با یک کاراکتر # و یک فاصله شروع می‌شن مگر اینکه داخل توضیحات هم تورفتگی داشته باشیم.
</p>

<p align=right>
‫پاراگراف‌ها داخل بلوک توضیحات با یک خط خالی که با کاراکتر # شروع می‌شه نشون داده می‌شن.
</p>

<h1 align=right>‫توضیحات درونی(Inline):</h1>

<p align=right>
‫توضیح درونی توضیحی که به همراه دستور در یک خط نوشته شود بطوری که حداقل با دو فاصله از دستور نوشته می‌شه و با کاراکتر # به همراه یک فاصله شروع می‌شه.
</p>

<p align=right>
‫توصیه: تا حد ممکن از توضیحات درونی استفاده نکنید!
</p>

<p align=right>
‫توضیحات درونی غیرلازم و در حقیقت اگر به شکل گویا نوشته نشن بیشتر گمراه‌کننده هستن. برای مثال:
</p>

<pre><code>No:
    x = x + 1  # Increment x
Yes:
    x = x + 1  # Compensate for border
</code></pre>

<h1>Documentation Strings:</h1>

<p align=right>
‫طبق معاهده‌ی نوشتن documentation strings که هم‌اکنون با اسم docstrings شناخته می‌شن:
</p>

<p align=right>
‫برای همه‌ی ماژول‌ها، توابع، کلاس‌ها و متد‌های عمومی docstring بنویسید. برای متد‌های غیر عمومی docstring لازم نیست ولی باید یه توضیح در مورد اینکه چی‌کار می‌کنه بعد از خط def نوشته می‌شه.
</p>

<p align=right>
‫برای docstring‌های چند خطی“““ انتهایی در یک خط جدا به تنهایی قرار می‌گیرد با این تفاوت که در docstring‌های تک خطی بهتر است در همان خط بماند.
</p>

<h1 align=right>
‫اصول نام‌گذاری:
</h1>

<p align=right>
‫سبک‌های نام‌‌گذاری مختلفی وجود داره. سبک‌های زیر جزء مرسوم‌ترین اونها هستن:
</p>

<p align=right>
‫* یک حرف کوچک (b)
</p>

<p align=right>
‫* یک حرف بزرگ (B)
</p>

<p align=right>
‫* حروف کوچک
</p>

<p align=right>
‫* حروف_کوچک_با_خط_زیر
</p>

<p align=right>
‫* حروف بزرگ
</p>

<p align=right>
‫* حروف_بزرگ_با_خط_زیر
</p>

<p align=right>
‫* کلمات با حرف اوّل بزرگ (CapWords) زمانیکه با سبک CapWords یک کلمه با اختصار رو می‌نویسید بهتره همه‌ی حروف کلمه‌ی اختصار رو به شکل بزرگ بنویسید. مثلاً HTTPServerError بهتر از HttpServerError هست.
</p>

<p align=right>
‫* MixedCase (با کاراکتر‌های اولیه‌ی کوچک با حالت CapitalizedWords متفاوت هست.)
</p>

<p align=right>
‫* کلمات_با_حروف_اوّل_بزرگ_به_همراه_خط_زیر.
</p>

<p align=right>
‫یه نوع استایل نام‌گذاری وجود داره به شکلی که نام‌ها با یک پیشوند دسته‌بندی می‌شن. درسته توی پایتون زیاد مرسوم نیست. برای مثال تابع ‪os.stat()‬ یک tuple برمی‌گردونه که اسامیشون به شکل زیر هستن: st_mode، st_size و امثال این‌ها.
</p>

<p align=right>
‫در کتابخانه‌ی X11 از کاراکتر X اوّل همه‌ی توابع عمومی استفاده می‌شود امّا در پایتون این استایل بیهوده هستِ چون نام خصوصیات و متد‌ها با پیشوند اسم شئ شروع می‌شه و اسم توابع با پیشوند اسم ماژول.
</p>

<p align=right>
‫علاوه بر این‌ها، فرم‌های خاص زیر از خط زیر در ابتدا و انتها استفاده می‌کنند که می‌توانند با سبک‌های نام گذاری قبلی بصورت ترکیبی مورد استفاده قرار گیرند:
</p>

<p align=right>
‫* ‌یک‌ـ‌خط‌زیر‌ـ‌درابتدا: XXXXXXXXXXXXXXXXXX. برای مثال دستور ‪from M import *‬ اشیائی که با خط زیر شروع می‌شن رو ایمپورت نمی‌کنه. این حالت به بقیه برنامه‌نویس‌ها می‌گه که این متد یا خصیصه پرایویت هست.
</p>

<p align=right>
‫* یک_خط‌زیر_درانتهاـ: برای جلوگیری از تعارض متغیر با keyword‌های پایتون:
</p>

```python
Tkinter.Toplevel(master, class_='ClassName')
```

<p align=right>
‫* __دوخط‌زیر_در ابتدا:XXXXXXXXXXXXX
</p>

<p align=right>
‫* __دوخط‌زیر_درابتدا_وانتها__: اشیاء و خصوصیات جادویی که در فضای نام کاربری موجود هستند. مانند __init__، __import__ یا __file__. هرگز از چنین اسامی استفاده نکنید، مگر برای استفاده در مستندسازی.
</p>


<h2 align=right>‫اسمامی ممنوعه:</h2>

<p align=right>
‫هرگز از کاراکتر‌های '‮l‬' (حرف کوچک L)، '‮O‬' (حرف بزرگ o) و '‮I‬' (حرف بزرگ i) به تنهایی به عنوان اسم متغیر استفاده نکنید. در برخی از فونت‌ها تفاوت این کاراکتر‌ها با اعداد یک و صفر قابل تشخیص نیست. اگر مجبور هستید مثلاً به جای استفاده از کاراکتر '‮l‬' از کاراکتر '‮L‬' استفاده کنید.
</p>

<h2 align=right>‫اسامی بسته‌ها و ماژول‌ها:</h2>

<p align=right>
‫ماژول‌ها باید اسمای کوتاه و تماماً با حروف کوچک داشته باشند، اگر به خوانایی آن کمک کند می‌توان از خط زیر هم استفاده کرد. بسته‌های پایتون هم باید اسامی کوتاه با حروف کوچک داشته باشند امّا استفاده از خط زیر به صلاح نیست.
</p>

<p align=right>
‫به علّت اینکه ماژول‌ها به یک فایل اشاره دارند، و در برخی از سیستم‌های فایل به حروف بزرگ و کوچک حساس نیستند و اسامی بلند را کوتاه می‌کنند، انتخاب اسم کوتاه برای ماژول‌ها مهم هست، البته این در سیستم‌های شبه Unix مشکلی ایجاد نمی‌کنه امّا اگر کد به سیستم‌های قدیمی Mac، ویندوز یا DOS منتقل بشه احتمالاً با مشکل مواجه خواهید شد.
</p>

<h2 align=right>‫اسامی کلاس‌ها:</h2>

<p align=right>
‫اسم کلاس‌ها در حالت عادی باید طبق قرارداد CapWords نوشته شوند.
</p>

<p align=right>
‫معاهده‌ی دیگری برای نام‌گذاری اسامی داخلی(builtin) وجود دارد، به این صورت که فقط با یک کلمه (یا دو کلمه‌ی چسبیده به هم) به سبک CapWords نوشته می‌شود.
</p>

<h2 align=right>‫اسامی متغیر‌های سراسری:</h2>

<p align=right>
‫مطمئن شوید که این متغیرها فقط برای استفاده در داخل ماژول‌ها هستند. ماژول‌هایی که برای استفاده به صورت from M import * طراحی شده‌اند باید از مکانیسم __all__ برای جلوگیری از دست‌یابی سراسری استفاده کنند یا از معاهده‌ی قدیمی خط‌ـ‌زیر در ابتدای اسم ماژول (می‌توانید همچنین ماژول‌هایی را ”ماژول‌های غیر عمومی“ بنامید) استفاده کنند.
</p>

<h2 align=right>‫اسم توابع:</h2>

<p align=right>
‫اسم توابع باید با حروف کوچک و کلمات جدا شده با خط_زیر به منظور حفظ خوانایی آن‌ها نوشته می‌شوند. استفاده از سبک mixedCase برای حفظ یکپارچگی با نسخه‌های قبلی نیز مجاز است.
</p>
